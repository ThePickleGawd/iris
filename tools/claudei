#!/usr/bin/env bash
# tools/claudei — Launch a Claude Code session for Iris with PTY proxy.
#
# Usage:
#   claudei                              # new session in current directory
#   claudei --resume <session_id>        # resume existing session
#   claudei --cwd /some/project          # specify working directory
#   claudei install                      # symlink to /usr/local/bin/claudei
#   claudei link                         # link Mac to iPad on the network
#
# Environment:
#   IRIS_BACKEND_URL   Backend base URL (default: http://localhost:8000)
#   IRIS_IPAD_URL      iPad base URL (default: http://dylans-ipad.local:8935)
#   CLAUDE_CMD         Claude Code binary (default: claude)

set -euo pipefail

usage() {
    cat <<'EOF'
Usage:
  claudei
  claudei --cwd /some/project
  claudei --resume <session_id>
  claudei [claude args...]
  claudei install
  claudei link
EOF
}

IRIS_BACKEND_URL="${IRIS_BACKEND_URL:-http://localhost:8000}"
export CLAUDE_CMD="${CLAUDE_CMD:-claude}"
SOCKET_PATH="/tmp/iris-claude.sock"
META_FILE="/tmp/iris-claude-meta.json"
IMAGES_DIR="/tmp/iris/images"
CLEANED_UP=0

json_payload() {
    python3 - "$@" <<'PY'
import json
import sys

if len(sys.argv) == 4:
    socket_path, cwd, pid = sys.argv[1], sys.argv[2], int(sys.argv[3])
    print(json.dumps({"socket_path": socket_path, "cwd": cwd, "pid": pid}))
elif len(sys.argv) == 2:
    socket_path = sys.argv[1]
    print(json.dumps({"socket_path": socket_path}))
else:
    raise SystemExit("invalid args")
PY
}

write_meta() {
    python3 - "$META_FILE" "$SOCKET_PATH" "$$" "$CWD" "$RESUME_ID" <<'PY'
import json
import sys
from datetime import datetime, timezone

meta_file, socket_path, pid, cwd, resume_id = sys.argv[1:]
payload = {
    "socket_path": socket_path,
    "pid": int(pid),
    "cwd": cwd,
    "resume_id": resume_id if resume_id else None,
    "started_at": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
}
with open(meta_file, "w", encoding="utf-8") as f:
    json.dump(payload, f, indent=4)
    f.write("\n")
PY
}

socket_is_live() {
    python3 - "$SOCKET_PATH" <<'PY'
import socket
import sys

path = sys.argv[1]
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.settimeout(0.25)
try:
    sock.connect(path)
    print("live")
except OSError:
    sys.exit(1)
finally:
    sock.close()
PY
}

# Handle `claudei install` subcommand
if [[ "${1:-}" == "install" ]]; then
    INSTALL_PATH="/usr/local/bin/claudei"
    IRIS_INSTALL_PATH="/usr/local/bin/iris"
    # Resolve through symlinks to find the real script location.
    REAL_SCRIPT="${BASH_SOURCE[0]}"
    while [[ -L "$REAL_SCRIPT" ]]; do
        LINK_DIR="$(cd -P "$(dirname "$REAL_SCRIPT")" && pwd)"
        LINK_TARGET="$(readlink "$REAL_SCRIPT")"
        if [[ "$LINK_TARGET" == /* ]]; then
            REAL_SCRIPT="$LINK_TARGET"
        else
            REAL_SCRIPT="$LINK_DIR/$LINK_TARGET"
        fi
    done
    SCRIPT_PATH="$(cd -P "$(dirname "$REAL_SCRIPT")" && pwd)/$(basename "$REAL_SCRIPT")"

    if [[ -L "$INSTALL_PATH" || -e "$INSTALL_PATH" ]]; then
        echo "Removing existing $INSTALL_PATH"
        sudo rm -f "$INSTALL_PATH"
    fi

    sudo ln -s "$SCRIPT_PATH" "$INSTALL_PATH"
    echo "Installed: $INSTALL_PATH -> $SCRIPT_PATH"

    # Install companion iris CLI if present (same repository).
    IRIS_SCRIPT_PATH="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)/iris"
    if [[ -f "$IRIS_SCRIPT_PATH" ]]; then
        if [[ -L "$IRIS_INSTALL_PATH" || -e "$IRIS_INSTALL_PATH" ]]; then
            echo "Removing existing $IRIS_INSTALL_PATH"
            sudo rm -f "$IRIS_INSTALL_PATH"
        fi
        sudo ln -s "$IRIS_SCRIPT_PATH" "$IRIS_INSTALL_PATH"
        echo "Installed: $IRIS_INSTALL_PATH -> $IRIS_SCRIPT_PATH"
    else
        echo "Skipping iris install: not found at $IRIS_SCRIPT_PATH"
    fi
    exit 0
fi

# Handle `claudei link` subcommand — connect this Mac to the iPad
if [[ "${1:-}" == "link" ]]; then
    IPAD_URL="${IRIS_IPAD_URL:-http://dylans-ipad.local:8935}"
    MAC_HOSTNAME="$(hostname -s)"

    # Get local IP on the same network as the iPad
    LOCAL_IP=$(python3 -c "import socket; s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(('8.8.8.8', 80)); print(s.getsockname()[0]); s.close()")
    if [[ -z "$LOCAL_IP" ]]; then
        echo "ERROR: Could not determine local IP address."
        exit 1
    fi

    echo "Linking to iPad at $IPAD_URL ..."
    echo "  Mac hostname: $MAC_HOSTNAME"
    echo "  Local IP:     $LOCAL_IP"
    echo "  Backend port: 8000"

    LINK_PAYLOAD=$(python3 -c "
import json
print(json.dumps({
    'id': '$MAC_HOSTNAME',
    'name': '$MAC_HOSTNAME',
    'platform': 'macOS',
    'ip': '$LOCAL_IP',
    'port': 8000
}))
")

    RESPONSE=$(curl -sf -X POST "$IPAD_URL/api/v1/link" \
        -H "Content-Type: application/json" \
        -d "$LINK_PAYLOAD" 2>&1) || {
        echo "ERROR: Failed to link to iPad at $IPAD_URL/api/v1/link"
        echo "  Is the iPad on the same network? Is the Iris app running?"
        exit 1
    }

    echo ""
    echo "Linked to iPad successfully."
    echo "  Response: $RESPONSE"
    exit 0
fi

# Parse arguments
CWD="$(pwd)"
RESUME_ID=""
EXTRA_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        --resume)
            if [[ $# -lt 2 ]]; then
                echo "ERROR: --resume requires a session id."
                usage
                exit 2
            fi
            RESUME_ID="$2"
            shift 2
            ;;
        --cwd)
            if [[ $# -lt 2 ]]; then
                echo "ERROR: --cwd requires a path."
                usage
                exit 2
            fi
            CWD="$2"
            shift 2
            ;;
        --)
            shift
            while [[ $# -gt 0 ]]; do
                EXTRA_ARGS+=("$1")
                shift
            done
            ;;
        *)
            EXTRA_ARGS+=("$1")
            shift
            ;;
    esac
done

if [[ ! -d "$CWD" ]]; then
    echo "ERROR: working directory does not exist: $CWD"
    exit 2
fi

# Ensure images directory exists for the image pipeline
mkdir -p "$IMAGES_DIR"

# Resolve the path to claudec-iris (sibling of this script, following symlinks)
_SELF="${BASH_SOURCE[0]}"
while [[ -L "$_SELF" ]]; do
    _DIR="$(cd -P "$(dirname "$_SELF")" && pwd)"
    _TARGET="$(readlink "$_SELF")"
    if [[ "$_TARGET" == /* ]]; then
        _SELF="$_TARGET"
    else
        _SELF="$_DIR/$_TARGET"
    fi
done
REAL_SCRIPT_DIR="$(cd -P "$(dirname "$_SELF")" && pwd)"
CLAUDEC_IRIS="$REAL_SCRIPT_DIR/claudec-iris"

if [[ ! -x "$CLAUDEC_IRIS" ]]; then
    echo "ERROR: claudec-iris not found at $CLAUDEC_IRIS"
    exit 1
fi

# Clean up stale socket only if it's not live.
if [[ -S "$SOCKET_PATH" ]]; then
    if socket_is_live >/dev/null 2>&1; then
        echo "ERROR: an active claudei session is already using $SOCKET_PATH"
        echo "Stop the existing session before starting a new one."
        exit 1
    fi
    echo "Removing stale socket at $SOCKET_PATH"
    rm -f "$SOCKET_PATH"
fi

# Export socket path for the Python proxy
export CLAUDE_SOCKET="$SOCKET_PATH"

# Build claudec-iris args
PROXY_ARGS=(-d "$CWD")
if [[ -n "$RESUME_ID" ]]; then
    PROXY_ARGS+=(--resume "$RESUME_ID")
fi
if [[ ${#EXTRA_ARGS[@]} -gt 0 ]]; then
    PROXY_ARGS+=("${EXTRA_ARGS[@]}")
fi

# Write meta file before launching so the backend can discover the socket
write_meta

echo "Iris Claude Code session"
echo "  Socket:  $SOCKET_PATH"
echo "  CWD:     $CWD"
echo "  Meta:    $META_FILE"
[[ -n "$RESUME_ID" ]] && echo "  Resume:  $RESUME_ID"
echo ""

# Notify backend that a live session is starting
REGISTER_PAYLOAD="$(json_payload "$SOCKET_PATH" "$CWD" "$$")"
curl -sf -X POST "$IRIS_BACKEND_URL/api/claude-code/sessions/register" \
    -H "Content-Type: application/json" \
    -d "$REGISTER_PAYLOAD" \
    >/dev/null 2>&1 || true

# Auto-link to iPad (best-effort, silent failure if iPad unreachable)
AUTO_LINK_IP=$(python3 -c "import socket; s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(('8.8.8.8', 80)); print(s.getsockname()[0]); s.close()" 2>/dev/null) || true
if [[ -n "${AUTO_LINK_IP:-}" ]]; then
    IPAD_URL="${IRIS_IPAD_URL:-http://dylans-ipad.local:8935}"
    AUTO_LINK_HOST="$(hostname -s)"
    AUTO_LINK_PAYLOAD=$(python3 -c "
import json
print(json.dumps({
    'id': '$AUTO_LINK_HOST',
    'name': '$AUTO_LINK_HOST',
    'platform': 'macOS',
    'ip': '$AUTO_LINK_IP',
    'port': 8000
}))
" 2>/dev/null) || true
    if [[ -n "${AUTO_LINK_PAYLOAD:-}" ]]; then
        curl -sf --connect-timeout 2 -X POST "$IPAD_URL/api/v1/link" \
            -H "Content-Type: application/json" \
            -d "$AUTO_LINK_PAYLOAD" \
            >/dev/null 2>&1 || true
    fi
fi

# Cleanup on exit
cleanup() {
    if [[ "$CLEANED_UP" -eq 1 ]]; then
        return
    fi
    CLEANED_UP=1

    echo ""
    echo "Cleaning up Iris session..."
    rm -f "$SOCKET_PATH" "$META_FILE"

    # Notify backend the session ended
    UNREGISTER_PAYLOAD="$(json_payload "$SOCKET_PATH")"
    curl -sf -X POST "$IRIS_BACKEND_URL/api/claude-code/sessions/unregister" \
        -H "Content-Type: application/json" \
        -d "$UNREGISTER_PAYLOAD" \
        >/dev/null 2>&1 || true
}
trap cleanup EXIT INT TERM

# Launch PTY proxy
set +e
"$CLAUDEC_IRIS" "${PROXY_ARGS[@]}"
PROXY_EXIT_CODE=$?
set -e
exit "$PROXY_EXIT_CODE"
